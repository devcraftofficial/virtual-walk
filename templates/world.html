<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Virtual Street Walk â€“ Avatar Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MODEL-VIEWER -->
  <script type="module" src="https://unpkg.com/@google/model-viewer@^3.3.0/dist/model-viewer.min.js"></script>

  <!-- MAPLIBRE -->
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>

  <style>
    :root {
      --bg-page: #020617;
      --text-main: #e5e7eb;
      --accent: #38bdf8;
      --radius-lg: 18px;
    }
    *, *::before, *::after { box-sizing: border-box; }

    body {
      margin: 0;
      background: radial-gradient(circle at top, #020617, #000 80%);
      font-family: system-ui, sans-serif;
      color: var(--text-main);
      overflow: hidden;
    }

    .viewer-panel {
      width: 100%;
      height: 100vh;
      position: relative;
    }
    .viewer-canvas {
      position: relative;
      width: 100%;
      height: 100%;
      background: #000;
      overflow: hidden;
    }

    /* Mini-map */
    .mini-map {
      position: absolute;
      top: 16px;
      left: 16px;
      width: 100px;
      height: 100px;
      border-radius: 999px;
      overflow: hidden;
      background: #020617;
      border: 2px solid rgba(148,163,184,0.6);
      box-shadow: 0 12px 30px rgba(0,0,0,0.75);
      cursor: pointer;
      z-index: 50;
    }
    .mini-map img { width: 100%; height: 100%; object-fit: cover; }

    /* Full map */
    #fullMapOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      backdrop-filter: blur(6px);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 200;
    }
    #fullMapContainer {
      width: 90%;
      height: 80%;
      background: #0b1120;
      border-radius: var(--radius-lg);
      border: 1px solid rgba(148,163,184,0.5);
      overflow: hidden;
    }
    #closeMapBtn {
      position: absolute;
      top: 30px;
      right: 40px;
      width: 48px;
      height: 48px;
      background: rgba(0,0,0,0.65);
      color: #fff;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 22px;
      z-index: 500;
    }

    /* Gender switch */
    .gender-row {
      position: absolute;
      top: 16px;
      right: 16px;
      z-index: 60;
    }
    .gender-buttons {
      display: flex;
      gap: 6px;
    }
    .gender-buttons button {
      padding: 6px 10px;
      font-size: 11px;
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.4);
      background: rgba(0,0,0,0.4);
      color: white;
      cursor: pointer;
      backdrop-filter: blur(8px);
    }
    .gender-buttons .active {
      background: #1d4ed8;
      border-color: #3b82f6;
    }

    /* Street info */
    .street-info {
      position: absolute;
      top: 60px;
      right: 16px;
      background: rgba(15,23,42,0.7);
      border: 1px solid rgba(148,163,184,0.4);
      padding: 8px 14px;
      border-radius: 12px;
      z-index: 50;
      max-width: 220px;
      font-size: 12px;
    }

    /* Video */
    #streetVideo {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
      pointer-events: none;
      transition: transform 0.15s ease-out, filter 0.3s ease-out;
    }

    /* Night overlay */
    #nightOverlay {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top, rgba(15,23,42,0.4), rgba(0,0,0,0.9));
      mix-blend-mode: multiply;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease-out;
      z-index: 2;
    }

    /* Avatar & shadow */
    #avatarShadow {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 45px;
      background: radial-gradient(circle, rgba(0,0,0,0.45), transparent);
      filter: blur(12px);
      z-index: 7;
    }
    #avatarMV {
      position: absolute;
      bottom: -15px;
      left: 50%;
      transform: translateX(-50%);
      width: 240px;
      height: 440px;
      z-index: 10;
      pointer-events: none;
    }

    /* Avatar speech bubble */
    #avatarSpeech {
      position: absolute;
      bottom: 410px;
      left: 50%;
      transform: translateX(-50%) translateY(6px);
      max-width: 260px;
      padding: 6px 10px;
      font-size: 12px;
      background: rgba(15,23,42,0.96);
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
      color: #e5e7eb;
      box-shadow: 0 18px 45px rgba(0,0,0,0.8);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.22s ease-out, transform 0.22s ease-out;
      z-index: 11;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }
    #avatarSpeech.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(-4px);
    }

    /* NEW: Street-side reply bubble (right side) */
    #streetSpeech {
      position: absolute;
      bottom: 420px;
      right: 40px;
      max-width: 240px;
      padding: 6px 10px;
      font-size: 12px;
      background: rgba(30,41,59,0.95);
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.7);
      color: #f1f5f9;
      box-shadow: 0 18px 45px rgba(0,0,0,0.8);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.22s ease-out, transform 0.22s ease-out;
      z-index: 12;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }
    #streetSpeech.visible {
      opacity: 1;
      transform: translateY(-4px);
    }

    /* Joystick */
    #joystickBase {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 96px;
      height: 96px;
      border-radius: 50%;
      background: rgba(15,23,42,0.85);
      border: 1px solid rgba(148,163,184,0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(8px);
      touch-action: none;
      z-index: 70;
    }
    #joystickKnob {
      width: 48px;
      height: 48px;
      background: #2563eb;
      border-radius: 50%;
      box-shadow: 0 0 0 4px rgba(37,99,235,0.4);
      touch-action: none;
    }

    @media (max-width: 768px) {
      #joystickBase { bottom: 90px; }
    }

    /* Fade layer */
    #fadeLayer {
      position: absolute;
      inset: 0;
      background: black;
      opacity: 0;
      transition: opacity 0.7s;
      pointer-events: none;
      z-index: 200;
    }

    /* Settings button */
    #settingsBtn {
      position: absolute;
      top: 126px;
      left: 16px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.7);
      color: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 60;
      font-size: 18px;
      backdrop-filter: blur(8px);
    }

    /* Settings panel */
    #settingsPanel {
      position: absolute;
      right: 16px;
      bottom: 80px;
      width: 260px;
      max-width: 70vw;
      background: rgba(15,23,42,0.96);
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,0.6);
      box-shadow: 0 18px 45px rgba(0,0,0,0.9);
      padding: 10px 12px 12px;
      z-index: 90;
      transform: translateY(12px);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.18s ease-out, transform 0.18s ease-out;
      font-size: 12px;
    }
    #settingsPanel.open {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

  </style>
</head>

<body>

<!-- FULL MAP OVERLAY -->
<div id="fullMapOverlay">
  <div id="fullMapContainer"></div>
  <button id="closeMapBtn">âœ•</button>
</div>

<!-- MAIN VIEWER -->
<div class="viewer-panel">
  <div class="viewer-canvas" id="viewerCanvas">

    <div id="miniMap" class="mini-map">
      <img src="/static/img/minimap_placeholder.png" alt="">
    </div>

    <button id="settingsBtn" aria-label="Settings">âš™</button>

    <div class="gender-row">
      <div class="gender-buttons">
        <button class="active" data-gender="male">Male</button>
        <button data-gender="female">Female</button>
      </div>
    </div>

    <div class="street-info">
      <h2 id="streetName">Select a Street</h2>
      <p id="streetLocation">Waitingâ€¦</p>
    </div>

    <!-- VIDEO -->
    <video id="streetVideo" preload="metadata" muted playsinline disablepictureinpicture>
      <source id="videoSource" src="">
    </video>

    <div id="nightOverlay"></div>

    <!-- AVATAR -->
    <div id="avatarShadow"></div>
    <model-viewer id="avatarMV"
      src="/static/avatars/male/idle.glb"
      autoplay
      shadow-intensity="1"
      disable-zoom
      disable-pan>
    </model-viewer>

    <!-- SPEECH BUBBLES -->
    <div id="avatarSpeech"></div>
    <div id="streetSpeech"></div> <!-- NEW -->

    <!-- JOYSTICK -->
    <div id="joystickBase">
      <div id="joystickKnob"></div>
    </div>

    <!-- SETTINGS PANEL -->
    <div id="settingsPanel" aria-label="View settings">
      <h3>View settings</h3>

      <div class="settings-section">
        <strong style="font-size:11px;">Video</strong>
        <div class="settings-row">
          <label for="setVideoMuted">Mute video</label>
          <input type="checkbox" id="setVideoMuted" checked>
        </div>
        <div class="settings-row">
          <label for="setVideoSlow">Slow motion</label>
          <input type="checkbox" id="setVideoSlow">
        </div>
      </div>

      <div class="settings-section">
        <strong style="font-size:11px;">Avatar</strong>
        <div class="settings-row">
          <label for="setHideAvatar">Hide avatar</label>
          <input type="checkbox" id="setHideAvatar">
        </div>
        <div class="settings-row">
          <label for="setWalkNoAvatar">Walk without avatar</label>
          <input type="checkbox" id="setWalkNoAvatar">
        </div>
      </div>

      <div class="settings-section">
        <strong style="font-size:11px;">Environment</strong>
        <div class="settings-row">
          <label for="setNightMode">Night view</label>
          <input type="checkbox" id="setNightMode">
        </div>
      </div>
    </div>

    <!-- FADE LAYER -->
    <div id="fadeLayer"></div>
  </div>
</div>

<!-- AUDIO -->
<audio id="footstepAudio" src="/static/audio/footsteps_loop.wav" loop preload="auto"></audio>
<audio id="voiceAudio" preload="auto"></audio>

<!-- DATA FROM FLASK -->
<script id="streets-data" type="application/json">
  {{ streets | tojson | safe }}
</script>

<script id="selected-street-data" type="application/json">
  {{ selected_street | tojson | safe if selected_street else 'null' }}
</script>


<script type="module">
/* ================== GLOBALS ================== */
const STREETS = JSON.parse(document.getElementById("streets-data").textContent);
const SELECTED = JSON.parse(document.getElementById("selected-street-data").textContent);

const video        = document.getElementById("streetVideo");
const vsrc         = document.getElementById("videoSource");
const avatar       = document.getElementById("avatarMV");
const shadowEl     = document.getElementById("avatarShadow");
const fadeLayer    = document.getElementById("fadeLayer");
const nightOverlay = document.getElementById("nightOverlay");
const footstepAudio = document.getElementById("footstepAudio");

const speechEl       = document.getElementById("avatarSpeech");
const streetSpeechEl = document.getElementById("streetSpeech"); // ðŸ‘ˆ NEW
const voiceAudio     = document.getElementById("voiceAudio");   // your main voice audio tag

const settingsBtn     = document.getElementById("settingsBtn");
const settingsPanel   = document.getElementById("settingsPanel");
const setVideoMuted   = document.getElementById("setVideoMuted");
const setVideoSlow    = document.getElementById("setVideoSlow");
const setHideAvatar   = document.getElementById("setHideAvatar");
const setWalkNoAvatar = document.getElementById("setWalkNoAvatar");
const setNightMode    = document.getElementById("setNightMode");

const joystickBase = document.getElementById("joystickBase");
const joystickKnob = document.getElementById("joystickKnob");

let currentIndex       = -1;
let currentVideos      = [];
let currentVideoIndex  = 0;
let currentGender      = "male";

let yawCurrent   = 180;
let yawTarget    = 180;
let currentDir   = 0;
let reversePlaying = false;
let headBob      = 0;
let bobDirection = 1;
let strafe       = 0;
let strafeOffset = 0;
const STRAFE_MAX = 120;

let joyActive    = false;
let fullMapReady = false;
let fullMap;

/* ========== AVATAR GLBs PRELOAD ========== */
const avatarSources = {
  male: {
    idle: "/static/avatars/male/idle.glb",
    walk: "/static/avatars/male/walk.glb"
  },
  female: {
    idle: "/static/avatars/female/idle.glb",
    walk: "/static/avatars/female/walk.glb"
  }
};

function preloadAvatars() {
  Object.values(avatarSources).forEach(group => {
    Object.values(group).forEach(url => {
      fetch(url).catch(() => {});
    });
  });
}
preloadAvatars();

/* ========== VOICE CLIPS ========== */
/*  Folders used (as per your structure):

    static/audio/greetings/male/...
    static/audio/greetings/female/...
    static/audio/street/reply_1.mp3, reply_2.mp3
    static/audio/teleport/tp_1.mp3 (optional extra)
*/

const voiceClips = {
  male: {
    greetings: [
      { text: "Good morning!",           file: "/static/audio/greetings/male/male_greet_1.mp3" },
      { text: "Hello there!",            file: "/static/audio/greetings/male/male_greet_2.mp3" },
      { text: "Hey ready for walk",      file: "/static/audio/greetings/male/male_greet_3.mp3" }
    ],
    teleport: [
      { text: "Teleporting to the next street.", file: "/static/audio/greetings/male/male_teleport_1.mp3" }
    ]
  },
  female: {
    greetings: [
      { text: "hello how are you today", file: "/static/audio/greetings/female/female_greet_1.mp3" },
      { text: "hi lets take a walk",     file: "/static/audio/greetings/female/female_greet_2.mp3" }
    ],
    teleport: [
      { text: "Teleporting to the next street.", file: "/static/audio/greetings/female/female_teleport_1.mp3" }
    ]
  }
};

/* ðŸ‘‰ NEW: street replies (someone else on street) */
const streetReplies = [
  { text: "Good morning!",      file: "/static/audio/street/reply_1.mp3" },
  { text: "Have a nice day!",   file: "/static/audio/street/reply_2.mp3" }
];

/* Optional: preload voice MP3s so first play is smooth */
function preloadVoices() {
  Object.values(voiceClips).forEach(set => {
    (set.greetings || []).forEach(clip => {
      const a = new Audio(); a.src = clip.file;
    });
    (set.teleport || []).forEach(clip => {
      const a = new Audio(); a.src = clip.file;
    });
  });

  streetReplies.forEach(clip => {
    const a = new Audio(); a.src = clip.file;
  });
}
preloadVoices();

/* ========== SPEECH BUBBLES + VOICE ========== */
let speechTimeout       = null;
let streetSpeechTimeout = null;
let lastGreetingTime    = 0;

/* Avatar bubble (center, above avatar) */
function showAvatarSpeech(text, duration) {
  if (!speechEl) return;
  if (!duration) duration = 2300;
  speechEl.textContent = text;
  speechEl.classList.add("visible");
  if (speechTimeout) clearTimeout(speechTimeout);
  speechTimeout = setTimeout(() => {
    speechEl.classList.remove("visible");
  }, duration);
}

/* Street bubble (right side â€“ OPTION A) */
function showStreetSpeech(text, duration) {
  if (!streetSpeechEl) return;
  if (!duration) duration = 2300;
  streetSpeechEl.textContent = text;
  streetSpeechEl.classList.add("visible");
  if (streetSpeechTimeout) clearTimeout(streetSpeechTimeout);
  streetSpeechTimeout = setTimeout(() => {
    streetSpeechEl.classList.remove("visible");
  }, duration);
}

/* Use one audio element for both, sequentially */
function playVoice(file) {
  if (!voiceAudio || !file) return;
  try {
    voiceAudio.pause();
    voiceAudio.currentTime = 0;
    voiceAudio.src = file;
    voiceAudio.play().catch(() => {});
  } catch (e) {
    // ignore
  }
}

/* Avatar speaks */
function speakAvatarLine(text, file, duration) {
  showAvatarSpeech(text, duration || 2200);
  playVoice(file);
}

/* Street person replies */
function speakStreetLine(text, file, duration) {
  showStreetSpeech(text, duration || 2200);
  playVoice(file);
}

/** Greeting + reply pair (avatar + someone from street) */
function playGreetingPair() {
  const avatarSet = voiceClips[currentGender];
  if (!avatarSet) return;
  const gArr = avatarSet.greetings || [];
  if (!gArr.length || !streetReplies.length) return;

  const greet = gArr[Math.floor(Math.random() * gArr.length)];
  const reply = streetReplies[Math.floor(Math.random() * streetReplies.length)];

  // Avatar says hi
  speakAvatarLine(greet.text, greet.file, 1500);

  // Street reply after a short delay (so it feels like conversation)
  setTimeout(() => {
    speakStreetLine(reply.text, reply.file, 2000);
  }, 1500);
}

/** Only greet occasionally when walking starts */
function maybeGreetOnWalkStart() {
  const now = Date.now();
  if (now - lastGreetingTime < 8000) return;
  if (Math.random() < 0.5) {
    playGreetingPair();
    lastGreetingTime = now;
  }
}

/* ================== VIDEO LOADING ================== */
function loadStreet(street) {
  document.getElementById("streetName").textContent = street.name || "Untitled Street";
  document.getElementById("streetLocation").textContent =
    (street.city || "") + (street.city && street.country ? ", " : "") + (street.country || "");

  currentVideos = [];
  currentVideoIndex = 0;

  if (Array.isArray(street.videos) && street.videos.length) {
    currentVideos = street.videos.map(v => v.url).filter(Boolean);
  } else if (street.videoUrl) {
    currentVideos = [street.videoUrl];
  }

  const url = currentVideos[0] || "";
  vsrc.src = url;
  video.load();
  video.currentTime = 0;
  video.pause();
}

function loadStreetByIndex(i) {
  if (i < 0 || i >= STREETS.length) return;
  currentIndex = i;
  loadStreet(STREETS[i]);
}

/* ================== PLAYBACK ================== */
function playForward() {
  reversePlaying = false;
  const slow = setVideoSlow.checked;
  video.playbackRate = slow ? 0.5 : 1;
  video.play().catch(() => {});
}

function playReverse() {
  reversePlaying = true;
  video.pause();
  function frameBack() {
    if (!reversePlaying) return;
    const slow = setVideoSlow.checked;
    const step = slow ? 0.008 : 0.016;
    video.currentTime -= step;
    if (video.currentTime <= 0.02) {
      video.currentTime = video.duration || 0;
    }
    requestAnimationFrame(frameBack);
  }
  requestAnimationFrame(frameBack);
}

function setAvatarState() {
  const state = currentDir === 0 ? "idle" : "walk";
  const src = avatarSources[currentGender] ? avatarSources[currentGender][state] : null;
  if (src) avatar.src = src;
}

/* Footsteps */
function updateFootsteps() {
  if (currentDir !== 0) {
    if (footstepAudio.paused) {
      footstepAudio.play().catch(() => {});
    }
  } else {
    footstepAudio.pause();
    footstepAudio.currentTime = 0;
  }
}

/* ================== NEAREST TELEPORT ================== */
function haversine(lat1, lon1, lat2, lon2) {
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) *
      Math.cos(lat2 * Math.PI / 180) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

function nearestStreetIndex() {
  const base = STREETS[currentIndex];
  if (!base) return -1;
  let best = -1;
  let bestDist = Infinity;
  STREETS.forEach((s, i) => {
    if (i === currentIndex) return;
    const d = haversine(
      parseFloat(base.lat),
      parseFloat(base.lng),
      parseFloat(s.lat),
      parseFloat(s.lng)
    );
    if (!Number.isNaN(d) && d < bestDist) {
      bestDist = d;
      best = i;
    }
  });
  return best;
}

async function teleportNearest() {
  const next = nearestStreetIndex();
  if (next === -1) return;

  // Teleport voice line (avatar only)
  const set   = voiceClips[currentGender];
  const teleArr = set && set.teleport ? set.teleport : [];
  if (teleArr.length) {
    const clip = teleArr[Math.floor(Math.random() * teleArr.length)];
    speakAvatarLine(clip.text, clip.file, 2600);
  } else {
    showAvatarSpeech("Teleporting to the next street.", 2600);
  }

  fadeLayer.style.opacity = "1";
  await new Promise(r => setTimeout(r, 450));
  loadStreetByIndex(next);
  fadeLayer.style.opacity = "0";
}

/* ================== VIDEO ENDED ================== */
video.addEventListener("ended", () => {
  if (currentVideos.length > 1 && currentVideoIndex < currentVideos.length - 1) {
    currentVideoIndex++;
    vsrc.src = currentVideos[currentVideoIndex] || "";
    video.load();
    video.currentTime = 0;
    if (currentDir === 1) playForward();
    return;
  }
  reversePlaying = false;
  currentDir = 0;
  video.pause();
  setAvatarState();
  updateFootsteps();
  teleportNearest();
});

/* ================== KEYBOARD CONTROLS ================== */
window.addEventListener("keydown", e => {
  const k = e.key.toLowerCase();
  if (k === "arrowleft" || k === "a") {
    yawTarget -= 10;
  } else if (k === "arrowright" || k === "d") {
    yawTarget += 10;
  } else if (k === "arrowup" || k === "w") {
    const wasStopped = currentDir === 0;
    currentDir = 1;
    playForward();
    setAvatarState();
    updateFootsteps();
    if (wasStopped) maybeGreetOnWalkStart();
  } else if (k === "arrowdown" || k === "s") {
    currentDir = -1;
    playReverse();
    setAvatarState();
    updateFootsteps();
  } else if (k === "q") {
    strafe = -1;
  } else if (k === "e") {
    strafe = 1;
  }
});

window.addEventListener("keyup", e => {
  const k = e.key.toLowerCase();
  if (["arrowup", "w", "arrowdown", "s"].includes(k)) {
    currentDir = 0;
    reversePlaying = false;
    video.pause();
    setAvatarState();
    updateFootsteps();
  }
  if (k === "q" || k === "e") {
    strafe = 0;
  }
});

/* ================== GENDER SWITCH ================== */
document.querySelectorAll(".gender-buttons button").forEach(btn => {
  btn.addEventListener("click", () => {
    document
      .querySelectorAll(".gender-buttons button")
      .forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    currentGender = btn.dataset.gender;
    setAvatarState();
  });
});

/* ================== JOYSTICK ================== */
function joyMove(ev) {
  const rect = joystickBase.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  const dx = ev.clientX - cx;
  const dy = ev.clientY - cy;
  const r  = rect.width / 2;

  const nx = dx / r;
  const ny = dy / r;

  joystickKnob.style.transform =
    "translate(" + nx * 30 + "px, " + ny * 30 + "px)";

  const prevDir = currentDir;

  if (Math.abs(ny) > 0.2) currentDir = ny < 0 ? 1 : -1;
  else currentDir = 0;

  if (Math.abs(nx) > 0.2) strafe = nx > 0 ? 1 : -1;
  else strafe = 0;

  if (currentDir === 1) {
    playForward();
    if (prevDir === 0) maybeGreetOnWalkStart();
  } else if (currentDir === -1) {
    playReverse();
  } else {
    reversePlaying = false;
    video.pause();
  }
  setAvatarState();
  updateFootsteps();
}

joystickBase.addEventListener("pointerdown", e => {
  joyActive = true;
  joystickBase.setPointerCapture(e.pointerId);
  joyMove(e);
});
joystickBase.addEventListener("pointermove", e => {
  if (joyActive) joyMove(e);
});
function resetJoystick() {
  joyActive = false;
  joystickKnob.style.transform = "translate(0,0)";
  currentDir = 0;
  strafe = 0;
  reversePlaying = false;
  video.pause();
  setAvatarState();
  updateFootsteps();
}
joystickBase.addEventListener("pointerup", resetJoystick);
joystickBase.addEventListener("pointercancel", resetJoystick);

/* ================== SETTINGS PANEL ================== */
settingsBtn.addEventListener("click", () => {
  settingsPanel.classList.toggle("open");
});

setVideoMuted.addEventListener("change", () => {
  video.muted = setVideoMuted.checked;
});
setVideoSlow.addEventListener("change", () => {
  if (!video.paused && !reversePlaying) {
    video.playbackRate = setVideoSlow.checked ? 0.5 : 1;
  }
});

function applyAvatarVisibility() {
  const hide = setHideAvatar.checked || setWalkNoAvatar.checked;
  avatar.style.display = hide ? "none" : "block";
  shadowEl.style.display = hide ? "none" : "block";
}
setHideAvatar.addEventListener("change", () => {
  if (setHideAvatar.checked) setWalkNoAvatar.checked = false;
  applyAvatarVisibility();
});
setWalkNoAvatar.addEventListener("change", () => {
  if (setWalkNoAvatar.checked) setHideAvatar.checked = false;
  applyAvatarVisibility();
});

setNightMode.addEventListener("change", () => {
  nightOverlay.style.opacity = setNightMode.checked ? "1" : "0";
});

video.muted = true;

/* ================== ANIMATION LOOP ================== */
function tick() {
  yawCurrent += (yawTarget - yawCurrent) * 0.18;
  avatar.orientation = "0deg 0deg " + yawCurrent + "deg";

  if (currentDir !== 0) {
    headBob += bobDirection * 0.25;
    if (headBob > 2 || headBob < -2) bobDirection *= -1;
  } else {
    headBob *= 0.85;
  }

  if (strafe !== 0) {
    strafeOffset += strafe * 4;
    if (strafeOffset > STRAFE_MAX)  strafeOffset = STRAFE_MAX;
    if (strafeOffset < -STRAFE_MAX) strafeOffset = -STRAFE_MAX;
  } else {
    strafeOffset *= 0.9;
  }

  video.style.transform  = "translateY(" + headBob + "px)";
  avatar.style.transform = "translate(calc(-50% + " + strafeOffset + "px), -15px)";

  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* ================== MAPLIBRE (LAZY) ================== */
function loadMap() {
  if (fullMapReady) return;
  fullMap = new maplibregl.Map({
    container: "fullMapContainer",
    style: "https://demotiles.maplibre.org/style.json",
    center: [0, 20],
    zoom: 2
  });
  fullMap.addControl(new maplibregl.NavigationControl());

  STREETS.forEach((s, i) => {
    const m = new maplibregl.Marker().setLngLat([
      parseFloat(s.lng),
      parseFloat(s.lat)
    ]).addTo(fullMap);
    m.getElement().addEventListener("click", () => {
      loadStreetByIndex(i);
      document.getElementById("fullMapOverlay").style.display = "none";
    });
  });

  fullMapReady = true;
}

document.getElementById("miniMap").onclick = () => {
  document.getElementById("fullMapOverlay").style.display = "flex";
  loadMap();
};
document.getElementById("closeMapBtn").onclick = () => {
  document.getElementById("fullMapOverlay").style.display = "none";
};

/* ================== INITIAL STREET ================== */
if (SELECTED) {
  const idx = STREETS.findIndex(s => s._id === SELECTED._id);
  loadStreetByIndex(idx !== -1 ? idx : 0);
} else if (Array.isArray(STREETS) && STREETS.length > 0) {
  loadStreetByIndex(0);
}
</script>

</body>
</html>
