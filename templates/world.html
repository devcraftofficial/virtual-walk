<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Virtual Street Walk â€“ Avatar Demo | ABTO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <!-- MODEL-VIEWER -->
  <script type="module" src="{{ url_for('static', filename='js/model-viewer.min.js') }}"></script>

  <!-- MAPLIBRE -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/maplibre-gl.css') }}">
  <script src="{{ url_for('static', filename='js/maplibre-gl.js') }}"></script>

  <style>
    :root {
      --bg-page: #020617;
      --text-main: #e5e7eb;
      --accent: #38bdf8;
      --radius-lg: 18px;
    }
    *, *::before, *::after { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at top, #020617, #000 80%);
      font-family: system-ui, sans-serif;
      color: var(--text-main);
      overflow: hidden;
    }

    .viewer-panel {
      width: 100%;
      height: 100vh;
      height: 100dvh; /* better on mobile */
      position: relative;
    }
    .viewer-canvas {
      position: relative;
      width: 100%;
      height: 100%;
      background: #000;
      overflow: hidden;
    }

    .mini-map {
      position: absolute;
      top: 16px;
      left: 16px;
      width: 100px;
      height: 100px;
      border-radius: 999px;
      overflow: hidden;
      background: #020617;
      border: 2px solid rgba(148,163,184,0.6);
      box-shadow: 0 12px 30px rgba(0,0,0,0.75);
      cursor: pointer;
      z-index: 50;
    }
    .mini-map img { width: 100%; height: 100%; object-fit: cover; }

    #fullMapOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      backdrop-filter: blur(6px);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 200;
      padding: 20px;
    }
    #fullMapContainer {
      width: 90%;
      height: 80%;
      background: #0b1120;
      border-radius: var(--radius-lg);
      border: 1px solid rgba(148,163,184,0.5);
      overflow: hidden;
      box-shadow: 0 25px 70px rgba(0,0,0,0.9);
    }
    #closeMapBtn {
      position: absolute;
      top: 30px;
      right: 40px;
      width: 48px;
      height: 48px;
      background: rgba(0,0,0,0.65);
      color: #fff;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 22px;
      z-index: 500;
      backdrop-filter: blur(4px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.8);
    }

    .gender-row {
      position: absolute;
      top: 16px;
      right: 16px;
      z-index: 60;
    }
    .gender-buttons {
      display: flex;
      gap: 6px;
    }
    .gender-buttons button {
      padding: 6px 10px;
      font-size: 11px;
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.4);
      background: rgba(0,0,0,0.4);
      color: white;
      cursor: pointer;
      backdrop-filter: blur(8px);
    }
    .gender-buttons .active {
      background: #1d4ed8;
      border-color: #3b82f6;
    }

    .street-info {
      position: absolute;
      top: 60px;
      right: 16px;
      background: rgba(15,23,42,0.7);
      border: 1px solid rgba(148,163,184,0.4);
      padding: 8px 14px;
      border-radius: 12px;
      z-index: 50;
      max-width: 220px;
      font-size: 12px;
    }

    #streetVideo {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
      pointer-events: none;
      transition: transform 0.12s ease-out, opacity 0.2s ease-out;
    }

    #walkVignette {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 55%, rgba(0,0,0,0.35) 85%);
      z-index: 3;
      opacity: 0;
      transition: opacity 0.3s ease-out;
    }

    #nightOverlay {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top, rgba(15,23,42,0.4), rgba(0,0,0,0.9));
      mix-blend-mode: multiply;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease-out;
      z-index: 2;
    }

    /* ===== AVATAR SHADOW + WRAPPER ===== */
    #avatarShadow {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 45px;
      background: radial-gradient(circle, rgba(0,0,0,0.45), transparent);
      filter: blur(12px);
      z-index: 7;
      transition: transform 0.12s ease-out;
    }

    #avatarWrapper {
      position: absolute;
      bottom: -15px;
      left: 50%;
      transform: translateX(-50%);
      width: 220px;
      height: 440px;
      z-index: 10;
      pointer-events: none;
    }

    #avatarMV {
      width: 100%;
      height: 100%;
      display: block;
      /* temporary debug so we know the slot is there */
      /* background: rgba(255,255,255,0.02); */
    }

    #avatarSpeech, #streetSpeech {
      font-size: 12px;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease-out, transform 0.2s ease-out;
      box-shadow: 0 18px 45px rgba(0,0,0,0.8);
      border: 1px solid rgba(148,163,184,0.7);
    }
    #avatarSpeech {
      position: absolute;
      bottom: 410px;
      left: 50%;
      transform: translateX(-50%) translateY(6px);
      max-width: 260px;
      padding: 6px 10px;
      background: rgba(15,23,42,0.96);
      border-radius: 999px;
      color: #e5e7eb;
      z-index: 11;
    }
    #streetSpeech {
      position: absolute;
      bottom: 420px;
      right: 40px;
      max-width: 240px;
      padding: 6px 10px;
      background: rgba(30,41,59,0.95);
      border-radius: 12px;
      color: #f1f5f9;
      z-index: 12;
    }
    #avatarSpeech.visible { opacity: 1; transform: translateX(-50%) translateY(-4px); }
    #streetSpeech.visible { opacity: 1; transform: translateY(-4px); }

    /* Transparent glass joystick */
    #joystickBase {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 96px;
      height: 96px;
      border-radius: 50%;
      background: radial-gradient(circle at center,
                  rgba(15, 23, 42, 0.353) 0%,
                  rgba(15, 23, 42, 0.249) 45%,
                  transparent 70%);
      border: 1px solid rgba(148, 163, 184, 0.555);
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(6px);
      touch-action: none;
      z-index: 70;
      opacity: 0.55;
      transition: opacity 0.18s ease-out, transform 0.18s ease-out;
    }

    #joystickBase.joy-active {
      opacity: 0.9;
      transform: scale(1.02);
    }

    #joystickKnob {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%,
                  rgba(56,189,248,0.85),
                  rgba(15,23,42,0.9));
      box-shadow:
        0 0 0 3px rgba(56,189,248,0.25),
        0 8px 18px rgba(0,0,0,0.65);
      touch-action: none;
    }

    @media (max-width: 768px) {
      #joystickBase {
        bottom: 90px;
      }
    }

    #fadeLayer {
      position: absolute;
      inset: 0;
      background: black;
      opacity: 0;
      transition: opacity 0.5s;
      pointer-events: none;
      z-index: 200;
    }

    #settingsBtn {
      position: absolute;
      top: 130px;
      left: 16px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.7);
      color: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 60;
      font-size: 18px;
      backdrop-filter: blur(8px);
    }

    #settingsPanel {
      position: absolute;
      right: 16px;
      bottom: 80px;
      width: 260px;
      max-width: 70vw;
      background: rgba(15,23,42,0.96);
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,0.6);
      box-shadow: 0 18px 45px rgba(0,0,0,0.9);
      padding: 10px 12px 12px;
      z-index: 90;
      transform: translateY(12px);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.18s ease-out, transform 0.18s ease-out;
      font-size: 12px;
    }
    #settingsPanel.open {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }
    .settings-section {
      margin-top: 8px;
      padding-top: 6px;
      border-top: 1px solid rgba(30,64,175,0.5);
    }
    .settings-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 4px;
      gap: 8px;
      font-size: 11px;
    }

    #streetPopup {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.65);
      backdrop-filter: blur(6px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }
    #streetPopupCard {
      width: 90%;
      max-width: 420px;
      background: rgba(15,23,42,0.92);
      border: 1px solid rgba(148,163,184,0.4);
      padding: 26px;
      border-radius: 18px;
      animation: popupFade 0.3s ease;
    }
    #streetPopupCard h2 {
      margin: 0 0 10px 0;
      font-size: 22px;
      color: var(--accent);
    }
    #streetPopupCard p {
      margin: 6px 0;
      font-size: 14px;
      color: var(--text-main);
    }
    #popupClose {
      margin-top: 16px;
      padding: 10px 22px;
      background: var(--accent);
      border: none;
      border-radius: 10px;
      color: #000;
      font-weight: 700;
      cursor: pointer;
      width: 100%;
    }
    @keyframes popupFade {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .map-marker-selected {
      width: 26px !important;
      height: 26px !important;
      background: #38bdf8 !important;
      border-radius: 50%;
      border: 3px solid white !important;
      box-shadow: 0 0 18px #38bdf8, 0 0 32px #38bdf8;
      animation: markerPulse 1.4s infinite ease-in-out;
    }
    @keyframes markerPulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.3); opacity: 0.7; }
      100% { transform: scale(1); opacity: 1; }
    }

    #videoLoading {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.9);
      z-index: 5;
      pointer-events: none;
    }
    #videoLoadingSpinner {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 3px solid rgba(148,163,184,0.4);
      border-top-color: #38bdf8;
      animation: spin 0.7s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Auto-walk button */
    #autoWalkBtn {
      position: absolute;
      right: 140px;
      bottom: 28px;
      width: 44px;
      height: 44px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
      background:
        radial-gradient(circle at 30% 30%, #38bdf8, #0f172a);
      box-shadow: 0 14px 30px rgba(0,0,0,0.8);
      color: #e5e7eb;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 72;
      outline: none;
      transition:
        transform 0.15s ease-out,
        box-shadow 0.15s ease-out,
        background 0.2s ease-out,
        opacity 0.2s ease-out;
    }
    #autoWalkBtn:hover {
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 18px 40px rgba(0,0,0,0.9);
    }
    #autoWalkBtn:active {
      transform: translateY(0) scale(0.97);
      box-shadow: 0 10px 22px rgba(0,0,0,0.75);
    }
    #autoWalkBtn.auto-on {
      background:
        radial-gradient(circle at 30% 30%, #22c55e, #022c22);
    }
    @media (max-width: 768px) {
      #autoWalkBtn {
        right: 118px;
        bottom: 200px;
        width: 42px;
        height: 42px;
        font-size: 17px;
      }
    }
    @media (max-width: 480px) {
      #autoWalkBtn {
        right: 20px;
        bottom: 200px;
      }
    }

    /* Brand pill: ABTO */
    .brand-pill {
      position: absolute;
      left: 16px;
      bottom: 22px;
      padding: 6px 14px;
      border-radius: 999px;
      background: rgba(15,23,42,0.92);
      border: 1px solid rgba(148,163,184,0.55);
      box-shadow: 0 14px 30px rgba(0,0,0,0.85);
      font-size: 11px;
      color: #e5e7eb;
      display: flex;
      align-items: center;
      gap: 6px;
      z-index: 60;
      backdrop-filter: blur(10px);
    }
    .brand-pill span.abto-tag {
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(56,189,248,0.18);
      border: 1px solid rgba(56,189,248,0.7);
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      font-size: 10px;
      color: #7dd3fc;
    }

    /* FULLSCREEN BUTTON (mobile focus) */
    .fullscreen-btn {
      position: absolute;
      right: 20px;
      bottom: 130px;
      width: 40px;
      height: 40px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
      background: rgba(15,23,42,0.9);
      color: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      cursor: pointer;
      z-index: 75;
      box-shadow: 0 14px 32px rgba(0,0,0,0.9);
      backdrop-filter: blur(8px);
    }
    @media (max-width: 768px) {
      .fullscreen-btn {
        bottom: 190px;
      }
    }
    @media (min-width: 1024px) {
      .fullscreen-btn {
        display: none;
      }
    }

    /* ORIENTATION GATE (mobile portrait) */
    .orientation-gate {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at top, #020617, #000 80%);
      display: none;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 40px 24px;
      z-index: 300;
    }
    .orientation-inner {
      max-width: 340px;
    }
    .orientation-icon {
      font-size: 46px;
      margin-bottom: 18px;
      display: inline-block;
      animation: rotateHint 1.8s ease-in-out infinite;
    }
    .orientation-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
    }
    .orientation-text {
      font-size: 14px;
      color: #9ca3af;
    }
    @keyframes rotateHint {
      0%, 100% { transform: rotate(0deg); }
      50%      { transform: rotate(90deg); }
    }
    @media (max-width: 768px) and (orientation: portrait) {
      .orientation-gate {
        display: flex;
      }
    }

    /* ===== MOBILE: smaller avatar & shadow ===== */
    @media (max-width: 900px) {
      #avatarWrapper {
        bottom: -4px;
        height: min(55vh, 300px);
      }

      #avatarShadow {
        bottom: 10px;
        width: 160px;
        height: 36px;
      }
    }
  </style>
</head>

<body>
  <!-- Orientation gate -->
  <div id="orientationGate" class="orientation-gate">
    <div class="orientation-inner">
      <div class="orientation-icon">ðŸ“±</div>
      <div class="orientation-title">Rotate your phone for Walk Mode</div>
      <p class="orientation-text">
        Avatar Walk Mode is best experienced in <strong>landscape</strong>.<br>
        Please rotate your phone sideways to see the full street view.
      </p>
    </div>
  </div>

  <div id="fullMapOverlay">
    <div id="fullMapContainer"></div>
    <button id="closeMapBtn">âœ•</button>
  </div>

  <div class="viewer-panel">
    <div class="viewer-canvas" id="viewerCanvas">
      <div id="miniMap" class="mini-map">
        <img src="/static/img/minimap_placeholder.png" alt="">
      </div>

      <div class="gender-row">
        <div class="gender-buttons">
          <button class="active" data-gender="male">Male</button>
          <button data-gender="female">Female</button>
        </div>
      </div>

      <div class="street-info">
        <h2 id="streetName">Select a Street</h2>
        <p id="streetLocation">Waitingâ€¦</p>
      </div>

      <!-- Brand pill -->
      <div class="brand-pill">
        <span class="abto-tag">ABTO</span>
        <span>A Better Travel Observer</span>
      </div>

      <button id="settingsBtn" aria-label="Settings">âš™</button>

      <video id="streetVideo" preload="metadata" muted playsinline disablepictureinpicture>
        <source id="videoSource" src="">
      </video>

      <div id="walkVignette"></div>

      <div id="videoLoading">
        <div id="videoLoadingSpinner"></div>
      </div>

      <div id="nightOverlay"></div>

      <div id="avatarShadow"></div>
      <div id="avatarWrapper">
        <model-viewer id="avatarMV"
          src="/static/avatars/male/idle.glb"
          autoplay
          shadow-intensity="1"
          orientation="0deg 0deg 180deg"
          disable-zoom
          disable-pan>
        </model-viewer>
      </div>

      <div id="avatarSpeech"></div>
      <div id="streetSpeech"></div>

      <div id="joystickBase">
        <div id="joystickKnob"></div>
      </div>

      <!-- Auto walk floating button -->
      <button id="autoWalkBtn" aria-label="Toggle auto walk">â–¶</button>

      <!-- Fullscreen button (mobile) -->
      <button id="fullscreenBtn" class="fullscreen-btn" aria-label="Enter full screen">â¤¢</button>

      <div id="settingsPanel" aria-label="View settings">
        <h3 style="margin:0 0 6px 0;font-size:13px;">View settings</h3>

        <div class="settings-section">
          <strong style="font-size:11px;">Video</strong>
          <div class="settings-row">
            <label for="setVideoMuted">Mute video</label>
            <input type="checkbox" id="setVideoMuted" checked>
          </div>
          <div class="settings-row">
            <label for="setVideoSlow">Slow motion</label>
            <input type="checkbox" id="setVideoSlow">
          </div>
        </div>

        <div class="settings-section">
          <strong style="font-size:11px;">Avatar</strong>
          <div class="settings-row">
            <label for="setHideAvatar">Hide avatar</label>
            <input type="checkbox" id="setHideAvatar">
          </div>
          <div class="settings-row">
            <label for="setWalkNoAvatar">Walk without avatar</label>
            <input type="checkbox" id="setWalkNoAvatar">
          </div>
        </div>

        <div class="settings-section">
          <strong style="font-size:11px;">Environment</strong>
          <div class="settings-row">
            <label for="setNightMode">Night view</label>
            <input type="checkbox" id="setNightMode">
          </div>
        </div>
      </div>

      <div id="streetPopup">
        <div id="streetPopupCard">
          <h2 id="popupTitle"></h2>
          <p id="popupCity"></p>
          <p id="popupCategory"></p>
          <p id="popupDescription"></p>
          <button id="popupClose">Close</button>
        </div>
      </div>

      <!-- Modern start hint -->
      <div id="startHint"
           style="position:absolute;inset:auto 0 82px 0;display:flex;justify-content:center;z-index:15;transition:opacity 0.25s ease-out;">
        <div style="display:flex;align-items:center;gap:10px;
                    background:rgba(15,23,42,0.92);
                    border-radius:999px;
                    padding:8px 14px;
                    border:1px solid rgba(148,163,184,0.55);
                    box-shadow:0 18px 45px rgba(0,0,0,0.85);
                    font-size:11px;
                    color:#e5e7eb;
                    backdrop-filter:blur(12px);">
          <span style="display:inline-flex;align-items:center;justify-content:center;
                       width:20px;height:20px;border-radius:999px;
                       background:rgba(56,189,248,0.16);
                       border:1px solid rgba(56,189,248,0.7);
                       font-size:11px;color:#7dd3fc;">
            â†‘
          </span>
          <span style="opacity:0.9;">
            Press <strong>W / â†‘</strong> or drag the joystick to start walking
          </span>
          <button id="startHintSkip"
                  style="margin-left:4px;border:none;background:transparent;
                         color:#9ca3af;font-size:11px;cursor:pointer;padding:0 2px;">
            Skip
          </button>
        </div>
      </div>

      <div id="fadeLayer"></div>
    </div>
  </div>

  <audio id="footstepAudio" src="/static/audio/footsteps_loop.wav" loop preload="auto"></audio>
  <audio id="voiceAudio" preload="auto"></audio>

  <script id="streets-data" type="application/json">
    {{ streets | tojson | safe }}
  </script>

  <script id="selected-street-data" type="application/json">
    {{ selected_street | tojson | safe if selected_street else 'null' }}
  </script>

  <script type="module">
    const DEBUG = false;

    let audioUnlocked = false;
    let lastFrameTime = 0;
    let isVideoLoading = false;
    let markerEls = [];

    // Safer JSON parsing
    let STREETS = [];
    let SELECTED = null;
    try {
      const streetsRaw = document.getElementById("streets-data").textContent || "[]";
      const selectedRaw = document.getElementById("selected-street-data").textContent || "null";
      STREETS = JSON.parse(streetsRaw);
      SELECTED = JSON.parse(selectedRaw);
    } catch (err) {
      console.error("Failed to parse street data", err);
      STREETS = [];
      SELECTED = null;
    }

    const video = document.getElementById("streetVideo");
    const vsrc = document.getElementById("videoSource");
    const avatar = document.getElementById("avatarMV");
    const avatarWrapper = document.getElementById("avatarWrapper");
    const shadowEl = document.getElementById("avatarShadow");
    const fadeLayer = document.getElementById("fadeLayer");
    const nightOverlay = document.getElementById("nightOverlay");
    const footstepAudio = document.getElementById("footstepAudio");
    const videoLoading = document.getElementById("videoLoading");
    const walkVignette = document.getElementById("walkVignette");

    const speechEl = document.getElementById("avatarSpeech");
    const streetSpeechEl = document.getElementById("streetSpeech");
    const voiceAudio = document.getElementById("voiceAudio");

    const settingsBtn = document.getElementById("settingsBtn");
    const settingsPanel = document.getElementById("settingsPanel");
    const setVideoMuted = document.getElementById("setVideoMuted");
    const setVideoSlow = document.getElementById("setVideoSlow");
    const setHideAvatar = document.getElementById("setHideAvatar");
    const setWalkNoAvatar = document.getElementById("setWalkNoAvatar");
    const setNightMode = document.getElementById("setNightMode");

    const joystickBase = document.getElementById("joystickBase");
    const joystickKnob = document.getElementById("joystickKnob");

    const startHint = document.getElementById("startHint");
    const startHintSkip = document.getElementById("startHintSkip");
    const autoWalkBtn = document.getElementById("autoWalkBtn");

    const fullMapOverlay = document.getElementById("fullMapOverlay");

    const orientationGate = document.getElementById("orientationGate");
    const fullscreenBtn = document.getElementById("fullscreenBtn");

    let hasStartedWalking = false;

    let currentIndex = -1;
    let currentVideos = [];
    let currentVideoIndex = 0;
    let currentGender = "male";
    let currentDir = 0;
    let reversePlaying = false;
    let headBob = 0;
    let bobDirection = 1;
    let strafe = 0;
    let strafeOffset = 0;
    const STRAFE_MAX = 120;
    let motionMomentum = 0;
    let joyActive = false;
    let fullMapReady = false;
    let fullMap;
    let isFirstStreetLoad = true;
    let speechTimeout = null;
    let streetSpeechTimeout = null;
    const GREETING_COOLDOWN = 6000;
    let lastGreetingAt = 0;
    let autoWalkEnabled = false;

    const avatarSources = {
      male: { idle: "/static/avatars/male/idle.glb", walk: "/static/avatars/male/walk.glb" },
      female: { idle: "/static/avatars/female/idle.glb", walk: "/static/avatars/female/walk.glb" }
    };

    function hideStartHint() {
      if (hasStartedWalking) return;
      hasStartedWalking = true;
      if (startHint) {
        startHint.style.opacity = "0";
        startHint.style.pointerEvents = "none";
        setTimeout(() => { startHint.style.display = "none"; }, 220);
      }
    }

    if (startHintSkip) {
      startHintSkip.addEventListener("click", hideStartHint);
    }

    function hardResetVideo() {
      video.pause();
      video.removeAttribute("src");
      video.load();
      video.currentTime = 0;
    }

    function unlockAudio() {
      if (audioUnlocked) return;
      [footstepAudio, voiceAudio].forEach(audio => {
        audio.muted = false;
        audio.play().then(() => {
          audio.pause();
          audio.currentTime = 0;
        }).catch(() => {});
      });
      audioUnlocked = true;
    }

    const dialogues = {
      male: [
        { q: "Good morning!", a: "Good morning! Have a nice day!", qFile: "/static/audio/greetings/male/male_greet_1.mp3", aFile: "/static/audio/street/reply_1.mp3" },
        { q: "Hello there!", a: "Hi! Welcome to the street!", qFile: "/static/audio/greetings/male/male_greet_2.mp3", aFile: "/static/audio/street/reply_2.mp3" },
        { q: "Hey, ready for a walk?", a: "Yes! Enjoy your walk!", qFile: "/static/audio/greetings/male/male_greet_3.mp3", aFile: "/static/audio/street/reply_3.mp3" },
        { q: "Nice to see you here!", a: "Nice to see you too, enjoy this place!", qFile: "/static/audio/greetings/male/male_greet_4.mp3", aFile: "/static/audio/street/reply_4.mp3" },
        { q: "Beautiful morning, right?", a: "Perfect time for a street walk!", qFile: "/static/audio/greetings/male/male_greet_5.mp3", aFile: "/static/audio/street/reply_5.mp3" }
      ],
      female: [
        { q: "Hello, how are you today?", a: "I'm good! Have a lovely day!", qFile: "/static/audio/greetings/female/female_greet_1.mp3", aFile: "/static/audio/street/reply_1.mp3" },
        { q: "Hi, let's take a walk.", a: "Sure! Welcome to the street!", qFile: "/static/audio/greetings/female/female_greet_2.mp3", aFile: "/static/audio/street/reply_2.mp3" },
        { q: "Good morning!", a: "Good morning! Enjoy your walk!", qFile: "/static/audio/greetings/female/female_greet_3.mp3", aFile: "/static/audio/street/reply_3.mp3" },
        { q: "Nice to meet you here!", a: "Nice to meet you too, enjoy this view!", qFile: "/static/audio/greetings/female/female_greet_4.mp3", aFile: "/static/audio/street/reply_4.mp3" },
        { q: "It's a beautiful day.", a: "Yes, perfect weather for walking!", qFile: "/static/audio/greetings/female/female_greet_5.mp3", aFile: "/static/audio/street/reply_5.mp3" }
      ]
    };

    const teleportLines = {
      male: [
        { text: "Teleporting to the next street.", file: "/static/audio/teleport/male_tp_1.mp3" },
        { text: "Jumping to another street!", file: "/static/audio/teleport/male_tp_2.mp3" },
        { text: "Hold tight, moving ahead!", file: "/static/audio/teleport/male_tp_3.mp3" }
      ],
      female: [
        { text: "Teleporting to the next street.", file: "/static/audio/teleport/female_tp_1.mp3" },
        { text: "Jumping to another cute street!", file: "/static/audio/teleport/female_tp_2.mp3" },
        { text: "Hold on, we're moving ahead!", file: "/static/audio/teleport/female_tp_3.mp3" }
      ]
    };

    function preloadAvatars() {
      Object.values(avatarSources).forEach(group => {
        Object.values(group).forEach(url => fetch(url).catch(() => {}));
      });
    }
    preloadAvatars();

    function preloadVoices() {
      Object.values(dialogues).forEach(list => {
        list.forEach(pair => {
          if (pair.qFile) new Audio(pair.qFile);
          if (pair.aFile) new Audio(pair.aFile);
        });
      });
      Object.values(teleportLines).forEach(list => {
        list.forEach(line => { if (line.file) new Audio(line.file); });
      });
    }
    preloadVoices();

    function showAvatarSpeech(text, duration = 2300) {
      speechEl.textContent = text;
      speechEl.classList.add("visible");
      clearTimeout(speechTimeout);
      speechTimeout = setTimeout(() => speechEl.classList.remove("visible"), duration);
    }

    function showStreetSpeech(text, duration = 2300) {
      streetSpeechEl.textContent = text;
      streetSpeechEl.classList.add("visible");
      clearTimeout(streetSpeechTimeout);
      streetSpeechTimeout = setTimeout(() => streetSpeechEl.classList.remove("visible"), duration);
    }

    function playVoice(file) {
      if (!file || !audioUnlocked) return;
      voiceAudio.pause();
      voiceAudio.currentTime = 0;
      voiceAudio.src = file;
      voiceAudio.play().catch(() => {});
    }

    function speakAvatarLine(text, file, duration) {
      showAvatarSpeech(text, duration || 2200);
      playVoice(file);
    }

    function speakStreetLine(text, file, duration) {
      showStreetSpeech(text, duration || 2200);
      playVoice(file);
    }

    function triggerGreeting() {
      const now = Date.now();
      if (now - lastGreetingAt < GREETING_COOLDOWN) return;
      const list = dialogues[currentGender] || dialogues.male;
      if (!list.length) return;
      const pair = list[Math.floor(Math.random() * list.length)];
      lastGreetingAt = now;
      speakAvatarLine(pair.q, pair.qFile, 1600);
      if (pair.a && pair.aFile) {
        setTimeout(() => speakStreetLine(pair.a, pair.aFile, 2000), 1400);
      }
    }

    function onWalkStart() {
      hideStartHint();
      triggerGreeting();
    }

    function buildVideoList(street) {
      const vids = [];
      if (Array.isArray(street.videos) && street.videos.length) {
        street.videos.forEach(v => { if (v && v.url) vids.push(v.url); });
      }
      if (!vids.length && street.videoUrl) vids.push(street.videoUrl);
      return vids;
    }

    function loadStreet(street) {
      if (!street || !street.name) {
        DEBUG && console.warn("Invalid street data:", street);
        return teleportNearest();
      }

      const nameEl = document.getElementById("streetName");
      const locEl = document.getElementById("streetLocation");

      nameEl.textContent = street.name || "Untitled Street";
      locEl.textContent =
        (street.city || "") +
        (street.city && street.country ? ", " : "") +
        (street.country || "");

      currentVideos = buildVideoList(street);

      if (!currentVideos.length) {
        DEBUG && console.warn("Street has no videos, skipping:", street.name);
        return teleportNearest();
      }

      currentVideoIndex = 0;

      if (isFirstStreetLoad) {
        videoLoading.style.display = "flex";
        video.style.opacity = "0";
      }

      if (isVideoLoading) return;
      isVideoLoading = true;

      const url = currentVideos[0];
      hardResetVideo();
      vsrc.src = url;
      video.load();

      const onVideoReady = () => {
        isVideoLoading = false;
        video.style.opacity = "1";
        if (isFirstStreetLoad) {
          videoLoading.style.display = "none";
          isFirstStreetLoad = false;
        }

        // If we were already walking/reversing, resume automatically
        if (currentDir === 1) {
          playForward();
        } else if (currentDir === -1) {
          playReverse();
        }
      };

      video.addEventListener("loadeddata", onVideoReady, { once: true });
      video.addEventListener("error", () => {
        DEBUG && console.warn("Video load failed:", url);
        isVideoLoading = false;
        if (isFirstStreetLoad) videoLoading.style.display = "none";
        teleportNearest();
      }, { once: true });
    }

    function loadStreetByIndex(i) {
      if (i < 0 || i >= STREETS.length) return;
      currentIndex = i;
      loadStreet(STREETS[i]);
      updateMapMarkerHighlight();
      if (fullMap && STREETS[i]) {
        const s = STREETS[i];
        fullMap.flyTo({ center: [parseFloat(s.lng), parseFloat(s.lat)], zoom: 12, speed: 0.9 });
      }
      preloadNextStreetVideo(i);
    }

    function preloadNextStreetVideo(fromIndex) {
      const base = STREETS[fromIndex];
      if (!base) return;
      const next = nearestStreetIndex();
      if (next === -1 || !STREETS[next]) return;
      const s = STREETS[next];
      const vids = buildVideoList(s);
      if (!vids.length) return;
      const url = vids[0];
      const link = document.createElement("link");
      link.rel = "preload";
      link.as = "video";
      link.href = url;
      document.head.appendChild(link);
    }

    function playForward() {
      reversePlaying = false;
      motionMomentum = Math.min(motionMomentum + 0.15, 1);
      if (audioUnlocked) {
        video.playbackRate = setVideoSlow.checked ? 0.5 : 1;
        video.play().catch(e => DEBUG && console.warn("Video play failed:", e));
      }
    }

    function playReverse() {
      if (!audioUnlocked) return;
      reversePlaying = true;
      video.pause();
      function frameBack() {
        if (!reversePlaying) return;
        const step = setVideoSlow.checked ? 0.008 : 0.016;
        video.currentTime -= step;
        if (video.currentTime <= 0.02) video.currentTime = video.duration || 0;
        requestAnimationFrame(frameBack);
      }
      requestAnimationFrame(frameBack);
    }

    function setAvatarState() {
      if (!avatar) return;
      const state = currentDir === 0 ? "idle" : "walk";
      const srcSet = avatarSources[currentGender] || avatarSources.male;
      const src = srcSet[state];
      if (src && avatar.getAttribute("src") !== src) {
        avatar.setAttribute("src", src);
      }
    }

    function updateFootsteps() {
      if (currentDir !== 0 && audioUnlocked) {
        if (footstepAudio.paused) footstepAudio.play().catch(() => {});
      } else {
        footstepAudio.pause();
        footstepAudio.currentTime = 0;
      }
    }

    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * Math.PI / 180) *
        Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function nearestStreetIndex() {
      const base = STREETS[currentIndex];
      if (!base || STREETS.length < 2) return -1;

      let best = -1;
      let bestDist = Infinity;
      const baseLat = parseFloat(base.lat);
      const baseLng = parseFloat(base.lng);

      STREETS.forEach((s, i) => {
        if (i === currentIndex) return;
        const d = haversine(baseLat, baseLng, parseFloat(s.lat), parseFloat(s.lng));
        if (!Number.isNaN(d) && d < bestDist) {
          bestDist = d;
          best = i;
        }
      });

      // If nothing "near", fall back to next street in list
      if (best === -1 || !Number.isFinite(bestDist) || bestDist > 0.8) {
        return (currentIndex + 1) % STREETS.length;
      }

      return best;
    }

    async function teleportNearest() {
      const next = nearestStreetIndex();
      if (next === -1) return;

      const list = teleportLines[currentGender] || teleportLines.male;
      if (list && list.length) {
        const line = list[Math.floor(Math.random() * list.length)];
        speakAvatarLine(line.text, line.file, 2200);
      }

      fadeLayer.style.opacity = "1";
      await new Promise(r => setTimeout(r, 350));
      loadStreetByIndex(next);
      fadeLayer.style.opacity = "0";
    }

    video.addEventListener("ended", () => {
      if (currentVideos.length > 1 && currentVideoIndex < currentVideos.length - 1) {
        currentVideoIndex++;
        const nextUrl = currentVideos[currentVideoIndex] || "";
        hardResetVideo();
        vsrc.src = nextUrl;
        video.load();
        video.currentTime = 0;
        if (currentDir === 1) playForward();
        return;
      }
      reversePlaying = false;
      currentDir = 0;
      video.pause();
      setAvatarState();
      updateFootsteps();
      teleportNearest();
    });

    function tick(currentTime = 0) {
      if (currentTime - lastFrameTime < 16) return requestAnimationFrame(tick);
      lastFrameTime = currentTime;

      if (document.hidden) {
        video.pause();
        footstepAudio.pause();
        return requestAnimationFrame(tick);
      }

      motionMomentum *= 0.92;
      if (motionMomentum < 0.02) motionMomentum = 0;

      if (currentDir !== 0) {
        headBob += bobDirection * 0.25 * motionMomentum;
        if (headBob > 2 || headBob < -2) bobDirection *= -1;
      } else {
        headBob *= 0.85 * motionMomentum;
      }

      if (strafe !== 0) {
        strafeOffset += strafe * 4;
        if (strafeOffset > STRAFE_MAX) strafeOffset = STRAFE_MAX;
        if (strafeOffset < -STRAFE_MAX) strafeOffset = -STRAFE_MAX;
      } else {
        strafeOffset *= 0.9;
      }

      const swayX = Math.sin(Date.now() * 0.002) * 2;
      const swayY = Math.cos(Date.now() * 0.0015) * 1.5;
      const walkIntensity = Math.abs(currentDir) > 0 ? motionMomentum : 0.3;

      video.style.transform =
        `translate(${strafeOffset * 0.25 + swayX * walkIntensity}px, ` +
        `${headBob * 1.4 + swayY * walkIntensity}px) scale(1.02)`;

      // Slide avatar wrapper slightly left/right with strafe
      if (avatarWrapper) {
        avatarWrapper.style.transform =
          `translate(calc(-50% + ${strafeOffset}px), 0px)`;
      }

      const shadowScale = 1 + Math.abs(headBob) * 0.04;
      shadowEl.style.transform = `translateX(-50%) scale(${shadowScale})`;

      walkVignette.style.opacity = walkIntensity > 0.1 ? walkIntensity * 0.7 : 0;
      footstepAudio.volume = Math.min(0.9, Math.abs(currentDir) * 0.7 + Math.abs(strafe) * 0.3);

      requestAnimationFrame(tick);
    }

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        video.pause();
        footstepAudio.pause();
        voiceAudio.pause();
      } else if (currentDir !== 0 && audioUnlocked) {
        playForward();
      }
    });

    window.addEventListener("pointerdown", unlockAudio, { once: true });
    window.addEventListener("keydown", unlockAudio, { once: true });

    function cancelAutoWalkIfUserMoves() {
      if (!autoWalkEnabled) return;
      setAutoWalk(false);
    }

    window.addEventListener("keydown", e => {
      const key = e.key;

      // ESC closes overlays & settings
      if (key === "Escape") {
        if (fullMapOverlay && fullMapOverlay.style.display === "flex") {
          fullMapOverlay.style.display = "none";
        }
        if (settingsPanel.classList.contains("open")) {
          settingsPanel.classList.remove("open");
        }
        return;
      }

      const k = key.toLowerCase();

      if (k === "arrowleft" || k === "a") {
        cancelAutoWalkIfUserMoves();
        strafe = -1;
      } else if (k === "arrowright" || k === "d") {
        cancelAutoWalkIfUserMoves();
        strafe = 1;
      } else if (k === "arrowup" || k === "w") {
        cancelAutoWalkIfUserMoves();
        const wasStopped = currentDir === 0;
        currentDir = 1;
        playForward();
        setAvatarState();
        updateFootsteps();
        if (wasStopped) onWalkStart();
      } else if (k === "arrowdown" || k === "s") {
        cancelAutoWalkIfUserMoves();
        currentDir = -1;
        playReverse();
        setAvatarState();
        updateFootsteps();
      }
    });

    window.addEventListener("keyup", e => {
      const k = e.key.toLowerCase();
      if (["arrowup", "w", "arrowdown", "s"].includes(k)) {
        currentDir = 0;
        motionMomentum = 0.8;
        reversePlaying = false;
        video.pause();
        setAvatarState();
        updateFootsteps();
      }
      if (k === "arrowleft" || k === "a" || k === "arrowright" || k === "d") {
        strafe = 0;
      }
    });

    document.querySelectorAll(".gender-buttons button").forEach(btn => {
      btn.addEventListener("click", () => {
        document.querySelectorAll(".gender-buttons button").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentGender = btn.dataset.gender;
        setAvatarState();
      });
    });

    function joyMove(ev) {
      cancelAutoWalkIfUserMoves(); // manual override cancels auto-walk

      const rect = joystickBase.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      const dx = ev.clientX - cx;
      const dy = ev.clientY - cy;
      const r = rect.width / 2;
      const nx = dx / r;
      const ny = dy / r;

      joystickKnob.style.transform = `translate(${nx * 30}px, ${ny * 30}px)`;

      const prevDir = currentDir;
      if (Math.abs(ny) > 0.2) currentDir = ny < 0 ? 1 : -1;
      else currentDir = 0;
      if (Math.abs(nx) > 0.2) strafe = nx > 0 ? 1 : -1;
      else strafe = 0;

      if (currentDir === 1) {
        playForward();
        if (prevDir === 0) onWalkStart();
      } else if (currentDir === -1) {
        playReverse();
      } else {
        motionMomentum = 0.8;
        reversePlaying = false;
        video.pause();
      }
      setAvatarState();
      updateFootsteps();
    }

    joystickBase.addEventListener("pointerdown", e => {
      joyActive = true;
      joystickBase.classList.add("joy-active");
      joystickBase.setPointerCapture(e.pointerId);
      joyMove(e);
    });
    joystickBase.addEventListener("pointermove", e => joyActive && joyMove(e));
    function resetJoystick() {
      joyActive = false;
      joystickBase.classList.remove("joy-active");
      joystickKnob.style.transform = "translate(0,0)";
      currentDir = 0;
      strafe = 0;
      motionMomentum = 0.8;
      reversePlaying = false;
      video.pause();
      setAvatarState();
      updateFootsteps();
    }
    joystickBase.addEventListener("pointerup", resetJoystick);
    joystickBase.addEventListener("pointercancel", resetJoystick);

    function setAutoWalk(on) {
      autoWalkEnabled = on;

      if (autoWalkEnabled) {
        currentDir = 1;
        playForward();
        setAvatarState();
        updateFootsteps();
        onWalkStart();
        if (autoWalkBtn) {
          autoWalkBtn.textContent = "â¸";
          autoWalkBtn.classList.add("auto-on");
        }
      } else {
        currentDir = 0;
        motionMomentum = 0.8;
        reversePlaying = false;
        video.pause();
        setAvatarState();
        updateFootsteps();
        if (autoWalkBtn) {
          autoWalkBtn.textContent = "â–¶";
          autoWalkBtn.classList.remove("auto-on");
        }
      }
    }

    if (autoWalkBtn) {
      autoWalkBtn.addEventListener("click", () => {
        if (!audioUnlocked) unlockAudio();
        setAutoWalk(!autoWalkEnabled);
      });
    }

    settingsBtn.addEventListener("click", () => settingsPanel.classList.toggle("open"));

    // Close settings when clicking outside
    document.addEventListener("click", (e) => {
      if (!settingsPanel.classList.contains("open")) return;
      if (settingsPanel.contains(e.target) || e.target === settingsBtn) return;
      settingsPanel.classList.remove("open");
    });

    setVideoMuted.addEventListener("change", () => video.muted = setVideoMuted.checked);
    setVideoSlow.addEventListener("change", () => {
      if (!video.paused && !reversePlaying) {
        video.playbackRate = setVideoSlow.checked ? 0.5 : 1;
      }
    });

    function applyAvatarVisibility() {
      const hide = setHideAvatar.checked || setWalkNoAvatar.checked;
      if (avatarWrapper) avatarWrapper.style.display = hide ? "none" : "block";
      shadowEl.style.display = hide ? "none" : "block";
    }
    setHideAvatar.addEventListener("change", () => {
      if (setHideAvatar.checked) setWalkNoAvatar.checked = false;
      applyAvatarVisibility();
    });
    setWalkNoAvatar.addEventListener("change", () => {
      if (setWalkNoAvatar.checked) setHideAvatar.checked = false;
      applyAvatarVisibility();
    });
    setNightMode.addEventListener("change", () => {
      nightOverlay.style.opacity = setNightMode.checked ? "1" : "0";
    });

    // Apply visibility once on load (in case browser remembers checkbox state)
    applyAvatarVisibility();

    function updateMapMarkerHighlight() {
      markerEls.forEach(({ el, index }) => {
        el.classList.toggle("map-marker-selected", index === currentIndex);
      });
    }

    function loadMap() {
      if (fullMapReady) return;
      fullMap = new maplibregl.Map({
        container: "fullMapContainer",
        style: "https://api.maptiler.com/maps/streets/style.json?key=PqdU3M5vnOQK0dDQnkIq",
        center: [0, 20],
        zoom: 2,
        pitch: 45,
        bearing: -20
      });
      fullMap.addControl(new maplibregl.NavigationControl());

      STREETS.forEach((s, i) => {
        if (!s.lat || !s.lng) return;
        const el = document.createElement("div");
        Object.assign(el.style, {
          width: "18px",
          height: "18px",
          borderRadius: "50%",
          background: "#3b82f6",
          border: "2px solid white",
          cursor: "pointer"
        });

        const popup = new maplibregl.Popup({ offset: 16 }).setHTML(
          `<div style="font-size:12px;color:#0f172a;">
            <strong>${s.name || "Street"}</strong><br/>
            <span>${s.city || ""}${s.country ? ", " + s.country : ""}</span>
          </div>`
        );

        const marker = new maplibregl.Marker({ element: el })
          .setLngLat([parseFloat(s.lng), parseFloat(s.lat)])
          .setPopup(popup)
          .addTo(fullMap);

        markerEls.push({ index: i, el, marker });

        el.addEventListener("click", () => {
          currentIndex = i;
          loadStreetByIndex(i);
          updateMapMarkerHighlight();
          const coords = marker.getLngLat();
          fullMap.flyTo({ center: [coords.lng, coords.lat], zoom: 13, speed: 0.9 });
          popup.addTo(fullMap);
          fullMapOverlay.style.display = "none";
        });
      });

      if (currentIndex !== -1 && STREETS[currentIndex]) {
        const st = STREETS[currentIndex];
        fullMap.flyTo({ center: [parseFloat(st.lng), parseFloat(st.lat)], zoom: 8, speed: 0.9 });
      }
      fullMapReady = true;
    }

    document.getElementById("miniMap").onclick = () => {
      fullMapOverlay.style.display = "flex";
      loadMap();
    };
    document.getElementById("closeMapBtn").onclick = () => {
      fullMapOverlay.style.display = "none";
    };

    const popupCard = document.getElementById("streetPopup");
    const popupTitle = document.getElementById("popupTitle");
    const popupCity = document.getElementById("popupCity");
    const popupCategory = document.getElementById("popupCategory");
    const popupDescription = document.getElementById("popupDescription");
    const popupClose = document.getElementById("popupClose");
    const streetNameEl = document.getElementById("streetName");

    streetNameEl.onclick = () => {
      const name = streetNameEl.textContent;
      const st = STREETS.find(s => s.name === name);
      if (!st) return;
      popupTitle.textContent = st.name;
      popupCity.textContent = `ðŸ“ ${st.city || ""}${st.country ? ", " + st.country : ""}`;
      popupCategory.textContent = st.category ? `ðŸ· Category: ${st.category}` : "ðŸ· No category";
      popupDescription.textContent = st.description || "No description added.";
      popupCard.style.display = "flex";
    };

    popupClose.onclick = () => popupCard.style.display = "none";
    popupCard.onclick = e => {
      if (e.target === popupCard) popupCard.style.display = "none";
    };

    video.muted = true;
    requestAnimationFrame(tick);

    if (SELECTED) {
      const idx = STREETS.findIndex(s => s._id === SELECTED._id);
      loadStreetByIndex(idx !== -1 ? idx : 0);
    } else if (Array.isArray(STREETS) && STREETS.length > 0) {
      loadStreetByIndex(0);
    }

    // ---------- Orientation gate (JS fallback) ----------
    function updateOrientationGate() {
      if (!orientationGate) return;
      const isMobile = window.innerWidth <= 768;
      const isPortrait = window.innerHeight >= window.innerWidth;
      orientationGate.style.display = (isMobile && isPortrait) ? "flex" : "none";
    }

    updateOrientationGate();
    window.addEventListener("resize", updateOrientationGate);
    window.addEventListener("orientationchange", updateOrientationGate);

    // ---------- Fullscreen handling ----------
    function isFullscreen() {
      return document.fullscreenElement ||
             document.webkitFullscreenElement ||
             document.msFullscreenElement;
    }

    function updateFullscreenIcon() {
      if (!fullscreenBtn) return;
      if (isFullscreen()) {
        fullscreenBtn.textContent = "â¤¡";
        fullscreenBtn.setAttribute("aria-label", "Exit full screen");
      } else {
        fullscreenBtn.textContent = "â¤¢";
        fullscreenBtn.setAttribute("aria-label", "Enter full screen");
      }
    }

    if (fullscreenBtn) {
      fullscreenBtn.addEventListener("click", async () => {
        try {
          if (!isFullscreen()) {
            const el = document.documentElement; // could be viewerCanvas instead
            if (el.requestFullscreen) {
              await el.requestFullscreen();
            } else if (el.webkitRequestFullscreen) {
              el.webkitRequestFullscreen();
            }
          } else {
            if (document.exitFullscreen) {
              await document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
              document.webkitExitFullscreen();
            }
          }
          updateFullscreenIcon();
        } catch (err) {
          console.log("Fullscreen error:", err);
        }
      });

      document.addEventListener("fullscreenchange", updateFullscreenIcon);
      document.addEventListener("webkitfullscreenchange", updateFullscreenIcon);
      updateFullscreenIcon();
    }
  </script>
</body>
</html>
